C51 COMPILER V9.53.0.0   UART5                                                             12/11/2024 15:57:35 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE UART5
OBJECT MODULE PLACED IN ..\OBJ\uart5.obj
COMPILER INVOKED BY: C:\Program Files (x86)\KEIL\C51\BIN\C51.EXE uart5.c LARGE OMF2 OPTIMIZE(3,SIZE) BROWSE INCDIR(..\US
                    -ER;..\FUNC_HANDLER;..\GUI_APP;..\HANDWARE\UART2) DEBUG PRINT(..\OBJ\uart5.lst) TABS(2) OBJECT(..\OBJ\uart5.obj)

line level    source

   1          
   2          
   3          #include "uart5.h"
   4          
   5          
   6          #if(UART5_INT_EN)
   7          xdata u16 uart5_rx_sta;//bit15Used to mark whether a complete data packet has been received, bit[14:0] is 
             -used to store the length of the current data packetxdata u8
   8          xdata u8  uart5_buf[UART5_PACKET_MAX_LEN+2];//Leave 2 blank characters
   9          xdata u8  uart5_step;
  10          
  11          //Serial port 5 interrupt service routine
  12          //When sending data, the interrupt must be turned off, here is only responsible for processing the receivi
             -ng interrupt.
  13          void uart5_isr() interrupt 13 { // –ê–¥—Ä–µ—Å –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏—è –¥–ª—è UART5 (0x6B)
  14   1          u8 res;
  15   1      
  16   1          if (SCON3R & 0x01) { // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ñ–ª–∞–≥ –ø—Ä–∏—ë–º–∞ RI3
  17   2              SCON3R &= ~0x01; // –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Ñ–ª–∞–≥ –ø—Ä–∏—ë–º–∞
  18   2              res = SBUF3_RX;  // –ß–∏—Ç–∞–µ–º –ø—Ä–∏–Ω—è—Ç—ã–µ –¥–∞–Ω–Ω—ã–µ –∏–∑ —Ä–µ–≥–∏—Å—Ç—Ä–∞
  19   2      
  20   2              if (uart5_rx_sta & UART5_PACKET_OK) {
  21   3                  // –ï—Å–ª–∏ —Ä–∞–Ω–µ–µ –ø—Ä–∏–Ω—è—Ç–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –µ—â—ë –Ω–µ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–æ, –
             -≤—ã—Ö–æ–¥–∏–º
  22   3                  return;
  23   3              }
  24   2      
  25   2              if (uart5_step == 0) { // –ù–∞—á–∏–Ω–∞–µ–º –æ–±—Ä–∞–±–æ—Ç–∫—É –ø—Ä–∏–Ω—è—Ç–æ–≥–æ –ø–∞–∫–µ—Ç–∞
  26   3                  if (res == '\r') {
  27   4                      // –ï—Å–ª–∏ –ø–æ–ª—É—á–µ–Ω —Å–∏–º–≤–æ–ª '\r', –ø–µ—Ä–µ—Ö–æ–¥–∏–º –∫ –æ–∂–∏–¥–∞–Ω–∏—é '\n'
  28   4                      uart5_step = 1;
  29   4                  } else if (res == '\n') {
  30   4                      // –ï—Å–ª–∏ –ø–æ–ª—É—á–µ–Ω —Å–∏–º–≤–æ–ª '\n', –ø–æ–º–µ—á–∞–µ–º –ø–∞–∫–µ—Ç –∫–∞–∫ –∑–∞–≤–µ—
             -Ä—à—ë–Ω–Ω—ã–π
  31   4                      uart5_rx_sta |= UART5_PACKET_OK;
  32   4                  } else {
  33   4                      // –°–æ—Ö—Ä–∞–Ω—è–µ–º –¥–∞–Ω–Ω—ã–µ –≤ –±—É—Ñ–µ—Ä, –µ—Å–ª–∏ —ç—Ç–æ –Ω–µ –∫–æ–Ω–µ—Ü –ø–∞–∫–µ
             -—Ç–∞
  34   4                      if (uart5_rx_sta >= UART5_PACKET_MAX_LEN) {
  35   5                          // –ï—Å–ª–∏ –±—É—Ñ–µ—Ä –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω, —Å–±—Ä–∞—Å—ã–≤–∞–µ–º —Å—Ç–∞—Ç—É—Å –∏ –Ω–∞
             -—á–∏–Ω–∞–µ–º –∑–∞–Ω–æ–≤–æ
  36   5                          uart5_rx_sta = 0;
  37   5                      }
  38   4                      uart5_buf[uart5_rx_sta++] = res; // –°–æ—Ö—Ä–∞–Ω—è–µ–º –¥–∞–Ω–Ω—ã–µ –≤ –±—É—Ñ–µ—Ä
  39   4                  }
  40   3              } else if (uart5_step == 1) { // –û–∂–∏–¥–∞–µ–º –∑–∞–≤–µ—Ä—à–∞—é—â–∏–π —Å–∏–º–≤–æ–ª '\n'
  41   3                  uart5_step = 0;
  42   3                  if (res == '\n') {
  43   4                      // –ï—Å–ª–∏ —Å–ª–µ–¥—É—é—â–∏–π —Å–∏–º–≤–æ–ª –ø–æ—Å–ª–µ '\r' ‚Äî —ç—Ç–æ '\n', –ø–æ–º–µ—á–∞–
             -µ–º –ø–∞–∫–µ—Ç –∑–∞–≤–µ—Ä—à—ë–Ω–Ω—ã–º
  44   4                      uart5_rx_sta |= UART5_PACKET_OK;
  45   4                  } else {
  46   4                      // –ï—Å–ª–∏ —ç—Ç–æ –Ω–µ '\n', —Å–±—Ä–∞—Å—ã–≤–∞–µ–º —Å—Ç–∞—Ç—É—Å –∏ –Ω–∞—á–∏–Ω–∞–µ–º –∑–∞–Ω
             -–æ–≤–æ
C51 COMPILER V9.53.0.0   UART5                                                             12/11/2024 15:57:35 PAGE 2   

  47   4                      uart5_rx_sta = 0;
  48   4                  }
  49   3              }
  50   2          }
  51   1      }
  52          
  53          #endif
  54          
  55          // Serial port 5 initialization
  56          void uart5_init(u32 baud) {
  57   1          // MUX_SEL |= 0x80; // Setting bit6 and bit7 to 1 exports UART5 interface to appropriate pins
  58   1          P0MDOUT &= 0x3F; // Clear bits for UART5 pins
  59   1          P0MDOUT |= 0x80; // Set P0.7 as output for TX and P0.6 as input for RX
  60   1      
  61   1          ADCON = 0x80; // Select SREL3H:L as the baud rate generator for UART5
  62   1          SCON3T = 0x80; // Enable transmission
  63   1          SCON3R = 0x80; // Enable reception
  64   1      
  65   1          // Baud rate setting formula:
  66   1          // SREL3H:L = 1024 - (FOSC / (32 * baud rate))
  67   1          baud = 1024 - (u16)(3225600.0f / baud);
  68   1          BODE3_DIV_H = (baud >> 8) & 0xFF; // High byte of the baud rate divisor
  69   1          BODE3_DIV_L = baud & 0xFF;        // Low byte of the baud rate divisor
  70   1      
  71   1          #if(UART5_INT_EN)
  72   1        
  73   1              IP1 = 0x28; // –ë–∏—Ç—ã 3 (G3) –∏ 5 (G5) —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã
  74   1              IP0 = 0x00; // –û—Å—Ç–∞–ª—å–Ω—ã–µ –≥—Ä—É–ø–ø—ã –æ—Å—Ç–∞—é—Ç—Å—è —Å –Ω–∏–∑–∫–∏–º –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç
             -–æ–º
  75   1      
  76   1              ES3R = 1; // Enable UART5 RX interrupt
  77   1              ES3T = 1; // Enable UART5 TX interrupt
  78   1              EA = 1;   // Enable global interrupts
  79   1          #else
                      ES3R = 0; // Disable UART5 RX interrupt
                      ES3T = 0; // Disable UART5 TX interrupt
                  #endif
  83   1      }
  84          
  85          
  86          void u5_send_byte(u8 byte) {
  87   1          ES3T = 0;              // –û—Ç–∫–ª—é—á–∞–µ–º –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏—è –ø–µ—Ä–µ–¥–∞—á–∏ –¥–ª—è UART5
  88   1          SBUF3_TX = byte;       // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –±–∞–π—Ç —á–µ—Ä–µ–∑ —Ä–µ–≥–∏—Å—Ç—Ä –ø–µ—Ä–µ–¥–∞—á–∏
  89   1          while (!SCON3T);          // –ñ–¥—ë–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –ø–µ—Ä–µ–¥–∞—á–∏ (TI3 == 1)
  90   1          SCON3T = 0;               // –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Ñ–ª–∞–≥ –ø–µ—Ä–µ–¥–∞—á–∏
  91   1          #if(UART5_INT_EN)
  92   1              ES3T = 1;          // –ü–æ–≤—Ç–æ—Ä–Ω–æ –≤–∫–ª—é—á–∞–µ–º –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏—è –ø–µ—Ä–µ–¥–∞—á–∏, –µ—
             -Å–ª–∏ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω—ã
  93   1          #endif
  94   1      }
  95          
  96          //Send data
  97          void u5_send_bytes(u8 *bytes, u16 len) {
  98   1          u16 i;
  99   1      
 100   1          ES3T = 0;              // –û—Ç–∫–ª—é—á–∞–µ–º –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏—è –ø–µ—Ä–µ–¥–∞—á–∏ UART5
 101   1          for (i = 0; i < len; i++) {
 102   2              SBUF3_TX = bytes[i]; // –ó–∞–ø–∏—Å—ã–≤–∞–µ–º —Ç–µ–∫—É—â–∏–π –±–∞–π—Ç –≤ —Ä–µ–≥–∏—Å—Ç—Ä –ø–µ—Ä–µ–¥–
             -∞—á–∏
 103   2              while (!(SCON3T & 0x01)); // –ñ–¥—ë–º, –ø–æ–∫–∞ —Ñ–ª–∞–≥ TI –Ω–µ –±—É–¥–µ—Ç —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω
 104   2              SCON3T &= ~0x01;       // –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Ñ–ª–∞–≥ TI
 105   2          }
C51 COMPILER V9.53.0.0   UART5                                                             12/11/2024 15:57:35 PAGE 3   

 106   1          #if(UART5_INT_EN)
 107   1              ES3T = 1;          // –í–∫–ª—é—á–∞–µ–º –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏—è –ø–µ—Ä–µ–¥–∞—á–∏, –µ—Å–ª–∏ –æ–Ω–∏ –∞–∫
             -—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω—ã
 108   1          #endif
 109   1      }
 110          
 111          
 112          //Implement printf function with uart2 serial port
 113          char putchar5(char c)
 114          {
 115   1        u5_send_byte(c);
 116   1        
 117   1        return c;
 118   1      }
 119          
 120          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    446    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    105      14
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
