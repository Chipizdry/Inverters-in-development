C51 COMPILER V9.53.0.0   UART2                                                             12/17/2024 10:33:37 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE UART2
OBJECT MODULE PLACED IN ..\OBJ\uart2.obj
COMPILER INVOKED BY: C:\Program Files (x86)\KEIL\C51\BIN\C51.EXE ..\HANDWARE\UART2\uart2.c LARGE OMF2 OPTIMIZE(3,SIZE) B
                    -ROWSE INCDIR(..\USER;..\FUNC_HANDLER;..\GUI_APP;..\HANDWARE\UART2) DEBUG PRINT(..\OBJ\uart2.lst) TABS(2) OBJECT(..\OBJ\u
                    -art2.obj)

line level    source

   1          #include "uart2.h"
   2          
   3          u8 modbus_addresses[5] = {1, 2, 3, 4, 5}; // –ê–¥—Ä–µ—Å–∞ —É—Å—Ç—Ä–æ–π—Å—Ç–≤
   4          u16 start_register = 0x0001;              // –ù–∞—á–∞–ª—å–Ω—ã–π —Ä–µ–≥–∏—Å—Ç—Ä
   5          u16 num_registers = 4;                    // –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ä–µ–≥–∏—Å—Ç—Ä–æ–≤
   6          u8 current_device = 0;                    // –¢–µ–∫—É—â–µ–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ –¥–ª—è –æ–ø—Ä–æ—Å–∞
   7          u8 polling_state = 0;                     // –°–æ—Å—Ç–æ—è–Ω–∏–µ –æ–ø—Ä–æ—Å–∞: 0 - –æ—Ç–ø—Ä–∞–≤–∫–∞, 1 - –æ
             -–∂–∏–¥–∞–Ω–∏–µ
   8          u16 polling_timer = 0;                    // –¢–∞–π–º–µ—Ä –æ–∂–∏–¥–∞–Ω–∏—è –æ—Ç–≤–µ—Ç–∞
   9          
  10          #if(UART2_INT_EN)
  11          xdata u16 uart2_rx_sta;//bit15Used to mark whether a complete data packet has been received, bit[14:0] is 
             -used to store the length of the current data packetxdata u8
  12          xdata u8  uart2_buf[UART2_PACKET_MAX_LEN+2];//Leave 2 blank characters
  13          xdata u8  uart2_step;
  14          
  15          //Serial port 2 interrupt service routine
  16          //When sending data, the interrupt must be turned off, here is only responsible for processing the receivi
             -ng interrupt.
  17          /*
  18          void uart2_isr()  interrupt 4
  19          {
  20            u8 res;
  21            
  22            if(RI0)//The serial port accepting the interrupt
  23            {
  24              RI0 = 0;//Clear accept interrupt flag
  25              res = SBUF0;//Read serial data
  26              
  27              if(uart2_rx_sta & UART2_PACKET_OK)//The received data has not been processed yet
  28                return;
  29            
  30              if(uart2_step==0)//The process of accepting data
  31              {
  32                if(res=='\r')//If the "\r\n" end marker is received, it is considered that the packet acceptance is com
             -plete
  33                  uart2_step = 1;//Enter the process of accepting the '\n' token
  34                else if(res=='\n')//If the '\n' end marker is received, it is also considered that the packet is accept
             -ed as complete
  35                  uart2_rx_sta |= UART2_PACKET_OK;//Mark packet acceptance complete
  36                else//Accept data
  37                {
  38                  if(uart2_rx_sta>=UART2_PACKET_MAX_LEN)
  39                    uart2_rx_sta = 0;//The data is too large, discard it, and start receiving from the beginning
  40          
  41                  uart2_buf[uart2_rx_sta++] = res;//Store valid data
  42                }
  43              }else if(uart2_step==1)//The process of judging the end tag
  44              {
  45                uart2_step = 0;
  46                if(res=='\n')
  47                  uart2_rx_sta |= UART2_PACKET_OK;//Mark packet acceptance complete
  48                else
C51 COMPILER V9.53.0.0   UART2                                                             12/17/2024 10:33:37 PAGE 2   

  49                  uart2_rx_sta = 0;//The next character of '\r' is not '\n', it is considered that the reception is wron
             -g, and the reception starts from the beginning
  50              }
  51              
  52            } 
  53          }
  54          */
  55          
  56          void uart2_isr() interrupt 4 {
  57   1          u8 res;
  58   1      
  59   1          if (RI0) {  // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ñ–ª–∞–≥ –ø—Ä–∏–µ–º–∞ –¥–∞–Ω–Ω—ã—Ö
  60   2              RI0 = 0;  // –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Ñ–ª–∞–≥ –ø—Ä–∏–µ–º–∞
  61   2      
  62   2              res = SBUF0;  // –ß–∏—Ç–∞–µ–º –ø—Ä–∏–Ω—è—Ç—ã–π –±–∞–π—Ç –¥–∞–Ω–Ω—ã—Ö –∏–∑ —Ä–µ–≥–∏—Å—Ç—Ä–∞
  63   2      
  64   2              // –ï—Å–ª–∏ –ø–∞–∫–µ—Ç —É–∂–µ –æ–±—Ä–∞–±–æ—Ç–∞–Ω, –∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º –¥–∞–ª—å–Ω–µ–π—à–∏–µ –¥–∞–Ω
             -–Ω—ã–µ
  65   2              if (uart2_rx_sta & UART2_PACKET_OK) {
  66   3                  return;
  67   3              }
  68   2      
  69   2              // –°–æ—Ö—Ä–∞–Ω—è–µ–º –¥–∞–Ω–Ω—ã–µ –≤ –±—É—Ñ–µ—Ä
  70   2              if (uart2_rx_sta < UART2_PACKET_MAX_LEN) {
  71   3                  uart2_buf[uart2_rx_sta++] = res;
  72   3              } else {
  73   3                  uart2_rx_sta = 0;  // –ï—Å–ª–∏ –±—É—Ñ–µ—Ä –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω, —Å–±—Ä–∞—Å—ã–≤–∞–µ–º
  74   3                  return;
  75   3              }
  76   2      
  77   2              // –ü—Ä–æ—Ü–µ—Å—Å –ø—Ä–∏–µ–º–∞ –¥–∞–Ω–Ω—ã—Ö –ø–æ —à–∞–≥–∞–º
  78   2              if (uart2_step<8) {  // –ü–µ—Ä–≤—ã–π –±–∞–π—Ç ‚Äî –∞–¥—Ä–µ—Å —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞
  79   3                  uart2_step++;
  80   3              } 
  81   2              
  82   2            if(uart2_step==8) {  // –î–∞–Ω–Ω—ã–µ —Ä–µ–≥–∏—Å—Ç—Ä–æ–≤ –∏ –∫–æ–Ω—Ç—Ä–æ–ª—å–Ω–∞—è —Å—É–º–º–∞ (–Ω–µ –∏—Å
             -–ø–æ–ª—å–∑—É–µ–º –¥–ª—è –≤—ã–≤–æ–¥–∞ –Ω–∞ —ç–∫—Ä–∞–Ω)
  83   3                  uart2_rx_sta |= UART2_PACKET_OK;  // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ñ–ª–∞–≥ –ø–∞–∫–µ—Ç–∞
  84   3                uart2_step =0;
  85   3              }
  86   2          }
  87   1      }
  88          #endif
  89          
  90          
  91          //Serial port 2 initialization
  92          void uart2_init(u32 baud)
  93          {
  94   1        MUX_SEL |= 0x40;//Setting bit6 to 1 means to export the uart2 interface to P0.4 and P0.5
  95   1        P0MDOUT &= 0xCF;
  96   1        P0MDOUT |= 0x10;//Set the corresponding IO port output and input
  97   1        ADCON = 0x80;//Select SREL0H:L as baud rate generator
  98   1        SCON0 = 0x50;//Accept enable and mode settings
  99   1        PCON &= 0x7F;//SMOD=0
 100   1        //Baud rate setting, the formula is:
 101   1        //SMOD=0  SREL0H:L=1024-main frequency/(64*baud rate),SMOD=1   SREL0H:L=1024-main frequency/(32*baud rate)
 102   1        baud = 1024-(u16)(3225600.0f/baud);
 103   1        SREL0H = (baud>>8)&0xff;  
 104   1        SREL0L = baud&0xff;
 105   1        
 106   1        #if(UART2_INT_EN)
 107   1          ES0 = 1;//Interrupt enable
C51 COMPILER V9.53.0.0   UART2                                                             12/17/2024 10:33:37 PAGE 3   

 108   1          EA = 1;
 109   1          //xdata variables must be initialized in functions
 110   1          uart2_rx_sta = 0;
 111   1          uart2_step = 0;
 112   1        #else
                  ES0 = 0;
                #endif
 115   1      
 116   1      }
 117          
 118          //Send a byte
 119          void u2_send_byte(u8 byte)
 120          {
 121   1        ES0 = 0;//Close the serial port 2 interrupt first
 122   1        SBUF0 = byte;
 123   1        while(!TI0);
 124   1        TI0 = 0;
 125   1        #if(UART2_INT_EN)
 126   1          ES0 = 1;//Re-open interrupt
 127   1        #endif
 128   1      }
 129          
 130          
 131          
 132          //Send data
 133          void u2_send_bytes(u8 *bytes,u16 len)
 134          {
 135   1        u16 i;
 136   1        
 137   1        ES0 = 0;//Close the serial port 2 interrupt first
 138   1        for(i=0;i<len;i++)
 139   1        {
 140   2          SBUF0 = bytes[i];
 141   2          while(!TI0);
 142   2          TI0 = 0;
 143   2        }
 144   1        #if(UART2_INT_EN)
 145   1          ES0 = 1;//Re-open interrupt
 146   1        #endif
 147   1      }
 148          
 149          
 150          //Implement printf function with uart2 serial port
 151          char putchar(char c)
 152          {
 153   1        u2_send_byte(c);
 154   1        
 155   1        return c;
 156   1      }
 157          
 158          
 159          
 160          
 161          u16 calculate_crc(unsigned char *buffer, unsigned char length) {
 162   1          unsigned int temp, temp2, flag;
 163   1          unsigned int i;               // –í—ã–Ω–µ—Å–µ–Ω–∏–µ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π `i`
 164   1          unsigned char j;              // –í—ã–Ω–µ—Å–µ–Ω–∏–µ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π `j`
 165   1      
 166   1          temp = 0xFFFF;
 167   1      
 168   1          for (i = 0; i < length; i++) {
 169   2              temp = temp ^ buffer[i];
C51 COMPILER V9.53.0.0   UART2                                                             12/17/2024 10:33:37 PAGE 4   

 170   2              for (j = 0; j < 8; j++) {
 171   3                  flag = temp & 0x0001;
 172   3                  temp >>= 1;
 173   3                  if (flag)
 174   3                      temp ^= 0xA001;
 175   3              }
 176   2          }
 177   1      
 178   1          // Reverse byte order.
 179   1          temp2 = temp >> 8;
 180   1          temp = (temp << 8) | temp2;
 181   1          temp &= 0xFFFF;
 182   1      
 183   1          return temp;
 184   1      }
 185          
 186          
 187          // –§—É–Ω–∫—Ü–∏—è —Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏—è –∏ –æ—Ç–ø—Ä–∞–≤–∫–∏ Modbus-–∑–∞–ø—Ä–æ—Å–∞
 188          void modbus_request(u8 address, u16 start_register, u16 num_registers) {
 189   1          u8 request[8];
 190   1          u16 crc;
 191   1      
 192   1          // –§–æ—Ä–º–∏—Ä—É–µ–º –∑–∞–ø—Ä–æ—Å Modbus
 193   1          request[0] = address;                      // –ê–¥—Ä–µ—Å —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞
 194   1          request[1] = 0x03;                         // –ö–æ–¥ —Ñ—É–Ω–∫—Ü–∏–∏ (—á—Ç–µ–Ω–∏–µ —Ä–µ–≥–∏—Å—Ç—Ä–æ–≤)
 195   1          request[2] = (start_register >> 8) & 0xFF; // –°—Ç–∞—Ä—à–∏–π –±–∞–π—Ç –Ω–∞—á–∞–ª—å–Ω–æ–≥–æ —Ä–µ–≥–∏—Å—
             -Ç—Ä–∞
 196   1          request[3] = start_register & 0xFF;        // –ú–ª–∞–¥—à–∏–π –±–∞–π—Ç –Ω–∞—á–∞–ª—å–Ω–æ–≥–æ —Ä–µ–≥–∏—Å—
             -Ç—Ä–∞
 197   1          request[4] = (num_registers >> 8) & 0xFF;  // –°—Ç–∞—Ä—à–∏–π –±–∞–π—Ç –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ —Ä–µ–≥–∏—Å—
             -Ç—Ä–æ–≤
 198   1          request[5] = num_registers & 0xFF;         // –ú–ª–∞–¥—à–∏–π –±–∞–π—Ç –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ —Ä–µ–≥–∏—Å—
             -Ç—Ä–æ–≤
 199   1      
 200   1          // –í—ã—á–∏—Å–ª—è–µ–º CRC
 201   1          crc = calculate_crc(request, 6);
 202   1          request[6] = crc & 0xFF;                   // –ú–ª–∞–¥—à–∏–π –±–∞–π—Ç CRC
 203   1          request[7] = (crc >> 8) & 0xFF;            // –°—Ç–∞—Ä—à–∏–π –±–∞–π—Ç CRC
 204   1      
 205   1          // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∑–∞–ø—Ä–æ—Å —á–µ—Ä–µ–∑ UART
 206   1          u2_send_bytes(request, 8);
 207   1      }
 208          
 209          // –§—É–Ω–∫—Ü–∏—è —Ü–∏–∫–ª–∏—á–µ—Å–∫–æ–≥–æ –æ–ø—Ä–æ—Å–∞ 5 –∞–¥—Ä–µ—Å–æ–≤ Modbus
 210          void poll_modbus_devices() {
 211   1          u8 modbus_addresses[5] = {1, 2, 3, 4, 5}; // –ê–¥—Ä–µ—Å–∞ —É—Å—Ç—Ä–æ–π—Å—Ç–≤
 212   1          u16 start_register = 0x0001;              // –ù–∞—á–∞–ª—å–Ω—ã–π —Ä–µ–≥–∏—Å—Ç—Ä
 213   1          u16 num_registers = 4;                    // –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ä–µ–≥–∏—Å—Ç—Ä–æ–≤
 214   1        unsigned int k; 
 215   1          while (1) {
 216   2              for (k = 0; k < 5; k++) {
 217   3                  // –§–æ—Ä–º–∏—Ä—É–µ–º –∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –∑–∞–ø—Ä–æ—Å –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –∞–¥—Ä–µ—Å–∞
 218   3                  modbus_request(modbus_addresses[k], start_register, num_registers);
 219   3      
 220   3                  // –ó–∞–¥–µ—Ä–∂–∫–∞ –º–µ–∂–¥—É –∑–∞–ø—Ä–æ—Å–∞–º–∏ –¥–ª—è –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏—è –Ω–∞–ª–æ
             -–∂–µ–Ω–∏—è
 221   3                  sys_delay_ms(900);
 222   3              }
 223   2      
 224   2              // –ó–∞–¥–µ—Ä–∂–∫–∞ –ø–µ—Ä–µ–¥ —Å–ª–µ–¥—É—é—â–∏–º —Ü–∏–∫–ª–æ–º –æ–ø—Ä–æ—Å–∞ –≤—Å–µ—Ö —É—Å—Ç—Ä–æ–π—
             -Å—Ç–≤
 225   2              sys_delay_ms(500);
C51 COMPILER V9.53.0.0   UART2                                                             12/17/2024 10:33:37 PAGE 5   

 226   2          }
 227   1      }
 228          
 229          
 230          
 231          
 232          
 233          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    898    ----
   CONSTANT SIZE    =      5    ----
   XDATA SIZE       =    118      53
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
