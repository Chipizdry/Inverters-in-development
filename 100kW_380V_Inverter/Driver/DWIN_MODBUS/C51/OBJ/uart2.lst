C51 COMPILER V9.53.0.0   UART2                                                             12/12/2024 16:04:59 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE UART2
OBJECT MODULE PLACED IN ..\OBJ\uart2.obj
COMPILER INVOKED BY: C:\Program Files (x86)\KEIL\C51\BIN\C51.EXE ..\HANDWARE\UART2\uart2.c LARGE OMF2 OPTIMIZE(3,SIZE) B
                    -ROWSE INCDIR(..\USER;..\FUNC_HANDLER;..\GUI_APP;..\HANDWARE\UART2) DEBUG PRINT(..\OBJ\uart2.lst) TABS(2) OBJECT(..\OBJ\u
                    -art2.obj)

line level    source

   1          #include "uart2.h"
   2          
   3          
   4          #if(UART2_INT_EN)
   5          xdata u16 uart2_rx_sta;//bit15Used to mark whether a complete data packet has been received, bit[14:0] is 
             -used to store the length of the current data packetxdata u8
   6          xdata u8  uart2_buf[UART2_PACKET_MAX_LEN+2];//Leave 2 blank characters
   7          xdata u8  uart2_step;
   8          
   9          //Serial port 2 interrupt service routine
  10          //When sending data, the interrupt must be turned off, here is only responsible for processing the receivi
             -ng interrupt.
  11          /*
  12          void uart2_isr()  interrupt 4
  13          {
  14            u8 res;
  15            
  16            if(RI0)//The serial port accepting the interrupt
  17            {
  18              RI0 = 0;//Clear accept interrupt flag
  19              res = SBUF0;//Read serial data
  20              
  21              if(uart2_rx_sta & UART2_PACKET_OK)//The received data has not been processed yet
  22                return;
  23            
  24              if(uart2_step==0)//The process of accepting data
  25              {
  26                if(res=='\r')//If the "\r\n" end marker is received, it is considered that the packet acceptance is com
             -plete
  27                  uart2_step = 1;//Enter the process of accepting the '\n' token
  28                else if(res=='\n')//If the '\n' end marker is received, it is also considered that the packet is accept
             -ed as complete
  29                  uart2_rx_sta |= UART2_PACKET_OK;//Mark packet acceptance complete
  30                else//Accept data
  31                {
  32                  if(uart2_rx_sta>=UART2_PACKET_MAX_LEN)
  33                    uart2_rx_sta = 0;//The data is too large, discard it, and start receiving from the beginning
  34          
  35                  uart2_buf[uart2_rx_sta++] = res;//Store valid data
  36                }
  37              }else if(uart2_step==1)//The process of judging the end tag
  38              {
  39                uart2_step = 0;
  40                if(res=='\n')
  41                  uart2_rx_sta |= UART2_PACKET_OK;//Mark packet acceptance complete
  42                else
  43                  uart2_rx_sta = 0;//The next character of '\r' is not '\n', it is considered that the reception is wron
             -g, and the reception starts from the beginning
  44              }
  45              
  46            } 
  47          }
  48          */
C51 COMPILER V9.53.0.0   UART2                                                             12/12/2024 16:04:59 PAGE 2   

  49          
  50          void uart2_isr() interrupt 4 {
  51   1          u8 res;
  52   1      
  53   1          if (RI0) {  // Проверяем флаг приема данных
  54   2              RI0 = 0;  // Сбрасываем флаг приема
  55   2      
  56   2              res = SBUF0;  // Читаем принятый байт данных из регистра
  57   2      
  58   2              // Если пакет уже обработан, игнорируем дальнейшие дан
             -ные
  59   2              if (uart2_rx_sta & UART2_PACKET_OK) {
  60   3                  return;
  61   3              }
  62   2      
  63   2              // Сохраняем данные в буфер
  64   2              if (uart2_rx_sta < UART2_PACKET_MAX_LEN) {
  65   3                  uart2_buf[uart2_rx_sta++] = res;
  66   3              } else {
  67   3                  uart2_rx_sta = 0;  // Если буфер переполнен, сбрасываем
  68   3                  return;
  69   3              }
  70   2      
  71   2              // Процесс приема данных по шагам
  72   2              if (uart2_step<8) {  // Первый байт — адрес устройства
  73   3                  uart2_step++;
  74   3              } 
  75   2              
  76   2            if(uart2_step==8) {  // Данные регистров и контрольная сумма (не ис
             -пользуем для вывода на экран)
  77   3                  uart2_rx_sta |= UART2_PACKET_OK;  // Устанавливаем флаг пакета
  78   3                uart2_step =0;
  79   3              }
  80   2          }
  81   1      }
  82          #endif
  83          
  84          
  85          //Serial port 2 initialization
  86          void uart2_init(u32 baud)
  87          {
  88   1        MUX_SEL |= 0x40;//Setting bit6 to 1 means to export the uart2 interface to P0.4 and P0.5
  89   1        P0MDOUT &= 0xCF;
  90   1        P0MDOUT |= 0x10;//Set the corresponding IO port output and input
  91   1        ADCON = 0x80;//Select SREL0H:L as baud rate generator
  92   1        SCON0 = 0x50;//Accept enable and mode settings
  93   1        PCON &= 0x7F;//SMOD=0
  94   1        //Baud rate setting, the formula is:
  95   1        //SMOD=0  SREL0H:L=1024-main frequency/(64*baud rate),SMOD=1   SREL0H:L=1024-main frequency/(32*baud rate)
  96   1        baud = 1024-(u16)(3225600.0f/baud);
  97   1        SREL0H = (baud>>8)&0xff;  
  98   1        SREL0L = baud&0xff;
  99   1        
 100   1        #if(UART2_INT_EN)
 101   1          ES0 = 1;//Interrupt enable
 102   1          EA = 1;
 103   1          //xdata variables must be initialized in functions
 104   1          uart2_rx_sta = 0;
 105   1          uart2_step = 0;
 106   1        #else
                  ES0 = 0;
                #endif
C51 COMPILER V9.53.0.0   UART2                                                             12/12/2024 16:04:59 PAGE 3   

 109   1      
 110   1      }
 111          
 112          //Send a byte
 113          void u2_send_byte(u8 byte)
 114          {
 115   1        ES0 = 0;//Close the serial port 2 interrupt first
 116   1        SBUF0 = byte;
 117   1        while(!TI0);
 118   1        TI0 = 0;
 119   1        #if(UART2_INT_EN)
 120   1          ES0 = 1;//Re-open interrupt
 121   1        #endif
 122   1      }
 123          
 124          
 125          
 126          //Send data
 127          void u2_send_bytes(u8 *bytes,u16 len)
 128          {
 129   1        u16 i;
 130   1        
 131   1        ES0 = 0;//Close the serial port 2 interrupt first
 132   1        for(i=0;i<len;i++)
 133   1        {
 134   2          SBUF0 = bytes[i];
 135   2          while(!TI0);
 136   2          TI0 = 0;
 137   2        }
 138   1        #if(UART2_INT_EN)
 139   1          ES0 = 1;//Re-open interrupt
 140   1        #endif
 141   1      }
 142          
 143          
 144          //Implement printf function with uart2 serial port
 145          char putchar(char c)
 146          {
 147   1        u2_send_byte(c);
 148   1        
 149   1        return c;
 150   1      }
 151          
 152          
 153          
 154          
 155          
 156          
 157          
 158          
 159          
 160          
 161          
 162          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    391    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    105      14
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
C51 COMPILER V9.53.0.0   UART2                                                             12/12/2024 16:04:59 PAGE 4   

   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
